<!DOCTYPE html>
<html lang="en-us">

<head>
  <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="shortcut icon" href="https://KTS-o7.github.io/bear/images/favicon.png" />
<title>SSE in FastAPI: The Tab Closed and My “Done” Code Never Ran | </title>
<meta name="title" content="SSE in FastAPI: The Tab Closed and My “Done” Code Never Ran" />
<meta name="description" content="I hit this bug the annoying way.
A coworker said: “I ran task generation, closed the tab, and the status never moved.”
My first reaction was “no way.” The backend is doing the work, not the browser.
Turns out… yeah. It was right. And once you see why, you stop trusting “code after the stream” forever.
This post is about a very specific trap:

you stream progress with SSE from a FastAPI endpoint
you put important side effects after the streaming loop (DB status updates, poller kickoff, Slack notifications)
a client disconnect cancels the stream
your “after the loop” code never runs

It doesn’t always fail. It fails just enough to make you doubt your own system." />
<meta name="author" content="" />
<meta name="keywords" content="" />






  
  <meta property="og:url" content="https://KTS-o7.github.io/bear/posts/sse_disconnect_handling/">
  <meta property="og:title" content="SSE in FastAPI: The Tab Closed and My “Done” Code Never Ran">
  <meta property="og:description" content="I hit this bug the annoying way.
A coworker said: “I ran task generation, closed the tab, and the status never moved.”
My first reaction was “no way.” The backend is doing the work, not the browser.
Turns out… yeah. It was right. And once you see why, you stop trusting “code after the stream” forever.
This post is about a very specific trap:
you stream progress with SSE from a FastAPI endpoint you put important side effects after the streaming loop (DB status updates, poller kickoff, Slack notifications) a client disconnect cancels the stream your “after the loop” code never runs It doesn’t always fail. It fails just enough to make you doubt your own system.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2026-01-23T00:00:00+00:00">
    <meta property="article:modified_time" content="2026-01-23T00:00:00+00:00">
    <meta property="og:image" content="https://KTS-o7.github.io/bear/images/share.webp">


  
  
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://KTS-o7.github.io/bear/images/share.webp">
  <meta name="twitter:title" content="SSE in FastAPI: The Tab Closed and My “Done” Code Never Ran">
  <meta name="twitter:description" content="I hit this bug the annoying way.
A coworker said: “I ran task generation, closed the tab, and the status never moved.”
My first reaction was “no way.” The backend is doing the work, not the browser.
Turns out… yeah. It was right. And once you see why, you stop trusting “code after the stream” forever.
This post is about a very specific trap:
you stream progress with SSE from a FastAPI endpoint you put important side effects after the streaming loop (DB status updates, poller kickoff, Slack notifications) a client disconnect cancels the stream your “after the loop” code never runs It doesn’t always fail. It fails just enough to make you doubt your own system.">


  
  
  <meta itemprop="name" content="SSE in FastAPI: The Tab Closed and My “Done” Code Never Ran">
  <meta itemprop="description" content="I hit this bug the annoying way.
A coworker said: “I ran task generation, closed the tab, and the status never moved.”
My first reaction was “no way.” The backend is doing the work, not the browser.
Turns out… yeah. It was right. And once you see why, you stop trusting “code after the stream” forever.
This post is about a very specific trap:
you stream progress with SSE from a FastAPI endpoint you put important side effects after the streaming loop (DB status updates, poller kickoff, Slack notifications) a client disconnect cancels the stream your “after the loop” code never runs It doesn’t always fail. It fails just enough to make you doubt your own system.">
  <meta itemprop="datePublished" content="2026-01-23T00:00:00+00:00">
  <meta itemprop="dateModified" content="2026-01-23T00:00:00+00:00">
  <meta itemprop="wordCount" content="2379">
  <meta itemprop="image" content="https://KTS-o7.github.io/bear/images/share.webp">

<meta name="referrer" content="no-referrer-when-downgrade" />

  
  <link href="/bear/herman.min.css" rel="stylesheet">

  
    
    <link href="/bear/syntax.min.css" rel="stylesheet">
  

  

  

  
</head>

<body>
  <header><a class="skip-link" href="#main-content">Skip to main content</a>

<a href="/bear/" class="title"><h1></h1></a>
<nav>
  <a href="/bear/">Home</a>

  <a href="/bear/posts/">Posts</a>

  <a href="/bear/about/">About</a>

  <a href="/bear/ml/">ML Stuff</a>

  <a href="/bear/cses.fi/">CSES.fi</a>

<a href='https://KTS-o7.github.io/bear/index.xml'>RSS</a>







</nav>
</header>
  <main id="main-content">

<h1>SSE in FastAPI: The Tab Closed and My “Done” Code Never Ran</h1>
<p class="byline">
  <time datetime='2026-01-23' pubdate>
    2026-01-23
  </time>
  
</p>

<content>
  <p>I hit this bug the annoying way.</p>
<p>A coworker said: “I ran task generation, closed the tab, and the status never moved.”</p>
<p>My first reaction was “no way.” The backend is doing the work, not the browser.</p>
<p>Turns out… yeah. It was right. And once you see why, you stop trusting “code after the stream” forever.</p>
<p>This post is about a very specific trap:</p>
<ul>
<li>you stream progress with SSE from a FastAPI endpoint</li>
<li>you put important side effects <em>after</em> the streaming loop (DB status updates, poller kickoff, Slack notifications)</li>
<li>a client disconnect cancels the stream</li>
<li>your “after the loop” code never runs</li>
</ul>
<p>It doesn’t always fail. It fails just enough to make you doubt your own system.</p>
<h2 id="what-the-system-looked-like-so-you-dont-think-this-is-a-demo-problem">What the system looked like (so you don’t think this is a demo problem)</h2>
<p>We had a step-based pipeline. Each step was triggered by an HTTP call from the frontend and did a few things:</p>
<ol>
<li>Receive a request like <code>POST /process-timeline-done</code> (or similar)</li>
<li>Start a long-ish worker (in our case an AI agent, but it could be anything)</li>
<li>Stream progress back to the UI via <strong>Server‑Sent Events</strong></li>
<li>Update state in MongoDB (advance a status field)</li>
<li>Submit an external job</li>
<li>Start a long poller to watch that job (hours sometimes)</li>
<li>Send a Slack notification</li>
</ol>
<p>Only (3) needs a live HTTP connection. The rest should be able to finish even if the user refreshes or closes the tab.</p>
<p>We had code split into things like:</p>
<table>
  <thead>
      <tr>
          <th>Component</th>
          <th>What it does</th>
          <th>Should it depend on HTTP?</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>CircularProcessorService</code></td>
          <td>Orchestrates the step</td>
          <td>Only for streaming</td>
      </tr>
      <tr>
          <td><code>JobPollingService</code></td>
          <td>Poll external job completion</td>
          <td>No</td>
      </tr>
      <tr>
          <td><code>ComplianceOSClient</code></td>
          <td>DB/API writes</td>
          <td>No</td>
      </tr>
      <tr>
          <td><code>SlackAlerts</code></td>
          <td>Notify humans</td>
          <td>No</td>
      </tr>
  </tbody>
</table>
<p>The bug was that our implementation accidentally made a bunch of “No” things depend on HTTP anyway.</p>
<h2 id="the-bug-the-exact-pattern">The bug (the exact pattern)</h2>
<p>This is the shape of the broken code:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1"># ❌ Broken: critical work is after streaming.</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">process_step</span><span class="p">():</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="k">async</span> <span class="k">for</span> <span class="n">update</span> <span class="ow">in</span> <span class="n">agent</span><span class="p">():</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">        <span class="k">yield</span> <span class="n">sse</span><span class="p">(</span><span class="n">update</span><span class="p">)</span>  <span class="c1"># disconnect can cancel/raise here</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="c1"># If the client disconnects, this may never run.</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">    <span class="k">await</span> <span class="n">db</span><span class="o">.</span><span class="n">update_status</span><span class="p">(</span><span class="s2">&#34;tasks_done&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl">    <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">start_polling</span><span class="p">(</span><span class="n">job_id</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">9</span><span class="cl">    <span class="k">await</span> <span class="n">slack</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="s2">&#34;done&#34;</span><span class="p">)</span></span></span></code></pre></div><p>It feels reasonable because it matches how we think:</p>
<p>“Stream updates while running… then when the loop ends, do the completion stuff.”</p>
<p>But in a streaming response, <em>the loop ending is not guaranteed</em>. The client can just leave.</p>
<h2 id="what-actually-happens-when-the-client-disconnects">What actually happens when the client disconnects</h2>
<p>Let’s make it concrete with a timeline.</p>
<p>Normal happy path:</p>





<pre tabindex="0"><code>Browser                  FastAPI/Starlette           MongoDB / External
   |                           |                          |
   | POST /process-step        |                          |
   |--------------------------&gt;|                          |
   | 200 OK (SSE stream)       |                          |
   |&lt;--------------------------|                          |
   | data: update #1           |                          |
   |&lt;--------------------------|                          |
   | data: update #2           |                          |
   |&lt;--------------------------|                          |
   | ...                       |                          |
   | data: final               |                          |
   |&lt;--------------------------|                          |
   | stream ends               |                          |
   |                           | update status            |
   |                           |-------------------------&gt;|
   |                           | start poller             |
   |                           |-------------------------&gt;|
   |                           | Slack notify             |
   |                           |-------------------------&gt;|</code></pre><p>Disconnect path:</p>





<pre tabindex="0"><code>Browser                  FastAPI/Starlette           MongoDB / External
   |                           |                          |
   | POST /process-step        |                          |
   |--------------------------&gt;|                          |
   | 200 OK (SSE stream)       |                          |
   |&lt;--------------------------|                          |
   | data: update #1           |                          |
   |&lt;--------------------------|                          |
   | data: update #2           |                          |
   |&lt;--------------------------|                          |
   | [tab closed]              |                          |
   X                           |                          |
                               | stream task canceled     |
                               | (right on a yield/send)  |
                               |                          |
                               | ❌ status update skipped  |
                               | ❌ poller never started   |
                               | ❌ Slack never sent       |</code></pre><p>The punchline is simple: <strong>SSE streaming is not “just a loop.” It’s a loop being consumed by a response writer that is allowed to stop at any time.</strong></p>
<h2 id="under-the-hood-why-starlette-cancels-your-generator">Under the hood (why Starlette cancels your generator)</h2>
<p>This is not the exact Starlette source code, but it matches the design.</p>
<p>Streaming responses typically run two things concurrently:</p>
<ul>
<li>a task that iterates your generator and sends chunks (<code>http.response.body</code>)</li>
<li>a task that listens for <code>http.disconnect</code></li>
</ul>
<p>When the disconnect happens, the server cancels the streaming task. That cancellation can hit while the framework is trying to send your last chunk… which was produced by your generator… which means your generator gets torn down mid-flight.</p>
<p>Two practical details that matter a lot:</p>
<ol>
<li>Cancellation shows up as <code>asyncio.CancelledError</code> (or sometimes as “write failed” type errors depending on stack).</li>
<li>In modern Python, <code>asyncio.CancelledError</code> is a <code>BaseException</code>, not an <code>Exception</code>. So <code>except Exception:</code> won’t catch it.</li>
</ol>
<p>That second one is why “but I wrapped it in try/except” doesn’t save you.</p>
<h2 id="a-minimal-repro-you-can-run-in-two-minutes">A minimal repro you can run in two minutes</h2>
<p>Here’s a tiny app that demonstrates the exact failure mode. The <code>print()</code> after the loop is your “update MongoDB status” in disguise.</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kn">import</span> <span class="nn">asyncio</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="kn">from</span> <span class="nn">fastapi</span> <span class="kn">import</span> <span class="n">FastAPI</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="kn">from</span> <span class="nn">starlette.responses</span> <span class="kn">import</span> <span class="n">StreamingResponse</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">app</span> <span class="o">=</span> <span class="n">FastAPI</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">gen</span><span class="p">():</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="k">yield</span> <span class="sa">f</span><span class="s2">&#34;data: </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&#34;</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;stream ended; now do side effects&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="nd">@app.get</span><span class="p">(</span><span class="s2">&#34;/sse&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">sse</span><span class="p">():</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="k">return</span> <span class="n">StreamingResponse</span><span class="p">(</span><span class="n">gen</span><span class="p">(),</span> <span class="n">media_type</span><span class="o">=</span><span class="s2">&#34;text/event-stream&#34;</span><span class="p">)</span></span></span></code></pre></div><p>Run it, then:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl">curl -N http://localhost:8000/sse</span></span></code></pre></div><p>Wait for a few numbers, hit <code>ctrl+c</code> in the <code>curl</code> terminal.</p>
<p>You will not see the “now do side effects” line.</p>
<p>That’s the bug.</p>
<h2 id="the-real-fix-stop-making-your-job-depend-on-the-http-stream">The real fix: stop making your job depend on the HTTP stream</h2>
<p>Once you accept “the client can vanish at any time”, the design gets boring (in a good way):</p>
<ul>
<li>The job runs to completion in a background task.</li>
<li>Streaming is just a best-effort view of progress.</li>
</ul>
<p>I like to think in terms of ownership:</p>
<ul>
<li>The worker owns side effects (DB writes, poller, Slack).</li>
<li>The request handler owns only streaming bytes to the client.</li>
</ul>
<h3 id="what-i-tried-first-and-why-it-didnt-help-backgroundtasks">What I tried first (and why it didn’t help): <code>BackgroundTasks</code></h3>
<p>FastAPI has <code>BackgroundTasks</code>. It’s useful, but it’s not a magic “disconnect-proof” button.</p>
<p>The catch is simple: background tasks are executed <em>after</em> the response is done.</p>
<p>For a normal JSON response, “response is done” means “we returned a body, the server wrote it, done.”</p>
<p>For an SSE response, “response is done” means “the stream ended.”</p>
<p>Which is… exactly the thing we can’t rely on.</p>
<p>If the client disconnects and the streaming response gets canceled, your “run this after the response” work is still hanging off the same lifecycle. It’s not the separation you actually want.</p>
<h3 id="cant-i-just-move-the-status-update-into-finally">“Can’t I just move the status update into <code>finally</code>?”</h3>
<p>This is another tempting fix:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">gen</span><span class="p">():</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">        <span class="k">async</span> <span class="k">for</span> <span class="n">update</span> <span class="ow">in</span> <span class="n">agent</span><span class="p">():</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">            <span class="k">yield</span> <span class="n">sse</span><span class="p">(</span><span class="n">update</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="k">finally</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">        <span class="k">await</span> <span class="n">db</span><span class="o">.</span><span class="n">update_status</span><span class="p">(</span><span class="s2">&#34;tasks_done&#34;</span><span class="p">)</span></span></span></code></pre></div><p>Sometimes it works. Sometimes it doesn’t. It depends on where cancellation lands.</p>
<p>Cancellation can interrupt awaits inside <code>finally</code> too. So you end up with a fun situation where you <em>thought</em> you made it reliable, but you just changed the probability of it failing.</p>
<p>If you really want to run cleanup under cancellation, you need to start thinking about shielding and cancel scopes. At that point you’re already halfway to the “worker owns completion” design anyway, so I’d rather just do it properly.</p>
<h3 id="the-queue-pattern-with-one-important-correction">The queue pattern (with one important correction)</h3>
<p>The common implementation is “worker pushes updates into a queue, streamer drains it.”</p>
<p>That’s fine, but there’s a nasty gotcha:</p>
<p>If the client disconnects and the streamer stops draining, <strong>a bounded queue can block your worker forever</strong>.</p>
<p>So don’t do this in your worker:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">await</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">update</span><span class="p">)</span>  <span class="c1"># ❌ can hang if consumer is gone</span></span></span></code></pre></div><p>If you do, you just recreated the original bug: completion is again tied to streaming, just indirectly.</p>
<p>What I do instead:</p>
<ul>
<li>Keep the queue bounded (to protect memory)</li>
<li>Put updates in a non-blocking way and drop when full</li>
<li>Stop queueing progress once the client is gone</li>
</ul>
<p>Here’s a practical sketch:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kn">import</span> <span class="nn">asyncio</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="kn">import</span> <span class="nn">json</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="kn">import</span> <span class="nn">logging</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="k">def</span> <span class="nf">sse</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="k">return</span> <span class="sa">f</span><span class="s2">&#34;data: </span><span class="si">{</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&#34;</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&#34;utf-8&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="k">def</span> <span class="nf">try_put</span><span class="p">(</span><span class="n">queue</span><span class="p">:</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Queue</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">        <span class="n">queue</span><span class="o">.</span><span class="n">put_nowait</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">QueueFull</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">        <span class="c1"># progress is optional; completion isn&#39;t</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">        <span class="k">pass</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="k">def</span> <span class="nf">log_task_result</span><span class="p">(</span><span class="n">task</span><span class="p">:</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Task</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">        <span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">CancelledError</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">        <span class="k">pass</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">        <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s2">&#34;background worker crashed&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">
</span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">run_to_completion</span><span class="p">(</span><span class="n">queue</span><span class="p">:</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Queue</span><span class="p">,</span> <span class="n">client_gone</span><span class="p">:</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Event</span><span class="p">):</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="n">job_id</span> <span class="o">=</span> <span class="kc">None</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">    <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">        <span class="k">async</span> <span class="k">for</span> <span class="n">update</span> <span class="ow">in</span> <span class="n">agent</span><span class="p">():</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">            <span class="n">job_id</span> <span class="o">=</span> <span class="n">job_id</span> <span class="ow">or</span> <span class="n">update</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&#34;job_id&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">            <span class="k">if</span> <span class="ow">not</span> <span class="n">client_gone</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">                <span class="n">try_put</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">update</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">
</span></span><span class="line"><span class="ln">33</span><span class="cl">        <span class="c1"># ✅ These must run even if client disconnects.</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl">        <span class="k">await</span> <span class="n">db</span><span class="o">.</span><span class="n">update_status</span><span class="p">(</span><span class="s2">&#34;tasks_done&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">35</span><span class="cl">        <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">start_polling</span><span class="p">(</span><span class="n">job_id</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl">        <span class="k">await</span> <span class="n">slack</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="s2">&#34;done&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">37</span><span class="cl">    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">38</span><span class="cl">        <span class="k">if</span> <span class="ow">not</span> <span class="n">client_gone</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
</span></span><span class="line"><span class="ln">39</span><span class="cl">            <span class="n">try_put</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="p">{</span><span class="s2">&#34;final&#34;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&#34;success&#34;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&#34;error&#34;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)})</span>
</span></span><span class="line"><span class="ln">40</span><span class="cl">        <span class="k">raise</span>
</span></span><span class="line"><span class="ln">41</span><span class="cl">    <span class="k">finally</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">42</span><span class="cl">        <span class="k">if</span> <span class="ow">not</span> <span class="n">client_gone</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
</span></span><span class="line"><span class="ln">43</span><span class="cl">            <span class="n">try_put</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># sentinel for streamer</span>
</span></span><span class="line"><span class="ln">44</span><span class="cl">
</span></span><span class="line"><span class="ln">45</span><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">stream</span><span class="p">(</span><span class="n">queue</span><span class="p">:</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Queue</span><span class="p">,</span> <span class="n">client_gone</span><span class="p">:</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Event</span><span class="p">):</span>
</span></span><span class="line"><span class="ln">46</span><span class="cl">    <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">47</span><span class="cl">        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">48</span><span class="cl">            <span class="n">item</span> <span class="o">=</span> <span class="k">await</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">49</span><span class="cl">            <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">50</span><span class="cl">                <span class="k">break</span>
</span></span><span class="line"><span class="ln">51</span><span class="cl">            <span class="k">yield</span> <span class="n">sse</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">52</span><span class="cl">    <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">CancelledError</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">53</span><span class="cl">        <span class="c1"># disconnected: stop streaming, signal worker to stop enqueueing</span>
</span></span><span class="line"><span class="ln">54</span><span class="cl">        <span class="n">client_gone</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">55</span><span class="cl">        <span class="k">raise</span>
</span></span><span class="line"><span class="ln">56</span><span class="cl">    <span class="k">finally</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">57</span><span class="cl">        <span class="n">client_gone</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">58</span><span class="cl">
</span></span><span class="line"><span class="ln">59</span><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">handler</span><span class="p">():</span>
</span></span><span class="line"><span class="ln">60</span><span class="cl">    <span class="n">queue</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Queue</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">61</span><span class="cl">    <span class="n">client_gone</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">62</span><span class="cl">
</span></span><span class="line"><span class="ln">63</span><span class="cl">    <span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">run_to_completion</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">client_gone</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">64</span><span class="cl">    <span class="n">task</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="n">log_task_result</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">65</span><span class="cl">
</span></span><span class="line"><span class="ln">66</span><span class="cl">    <span class="k">return</span> <span class="n">StreamingResponse</span><span class="p">(</span><span class="n">stream</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">client_gone</span><span class="p">),</span> <span class="n">media_type</span><span class="o">=</span><span class="s2">&#34;text/event-stream&#34;</span><span class="p">)</span></span></span></code></pre></div><p>Is it perfect? No. But it has the right shape:</p>
<ul>
<li>worker can finish without a consumer</li>
<li>progress streaming is best-effort</li>
<li>failures are logged instead of silently disappearing</li>
</ul>
<p>If you want something more durable (client reconnects and can replay progress), you need to store progress somewhere real (Redis/pubsub, DB, etc.). In-memory queues won’t do that. But that’s a different problem.</p>
<h2 id="the-architecture-i-like-better-when-this-gets-serious">The architecture I like better (when this gets serious)</h2>
<p>The queue pattern is fine when:</p>
<ul>
<li>you mostly care about “don’t lose completion when the client disconnects”</li>
<li>you don’t care about reconnecting and replaying a progress history</li>
</ul>
<p>But once you ship this to real users, you’ll hit two common problems:</p>
<ol>
<li>Browsers reconnect SSE automatically (especially <code>EventSource</code>), and you don’t want a reconnect to re-run the job.</li>
<li>People refresh and expect to see progress again (or at least not lose the final result).</li>
</ol>
<p>So the more robust shape is:</p>
<ol>
<li><code>POST /steps/{step}/start</code> → returns a <code>run_id</code></li>
<li>Worker runs independent of any SSE connection and persists state (status + maybe progress)</li>
<li><code>GET /runs/{run_id}/events</code> → SSE stream that is purely “subscribe”, not “start”</li>
</ol>
<p>Now reconnecting is safe. You might lose some live updates, but you can always read the current status from MongoDB, and you can keep polling running even if nobody is watching.</p>
<p>If you want a really clean UX, you can also persist event ids and support <code>Last-Event-ID</code>, but that’s optional. The big win is separating “start work” from “watch work.”</p>
<h2 id="sse-details-that-are-boring-but-matter">SSE details that are boring but matter</h2>
<p>SSE is “simple” in the same way DNS is “simple.”</p>
<p>It works great until you put it behind real infrastructure.</p>
<h3 id="event-formatting-is-strict">Event formatting is strict</h3>
<p>Each event ends with a blank line. If you forget the blank line, the browser buffers and you’ll think streaming is broken.</p>
<p>Simplest possible event:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">data: {&#34;message&#34;:&#34;hi&#34;}</span></span></code></pre></div><p>(Yes, that extra newline is part of it.)</p>
<h3 id="keepalives">Keepalives</h3>
<p>If your worker can go quiet for a while, send a comment every ~15–30 seconds so proxies don’t decide the connection is “idle”:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">yield</span> <span class="sa">b</span><span class="s2">&#34;: keep-alive</span><span class="se">\n\n</span><span class="s2">&#34;</span></span></span></code></pre></div><h3 id="nginx-buffering">Nginx buffering</h3>
<p>If your stream arrives in one big chunk at the end, it’s usually Nginx buffering.</p>
<p>You don’t fix buffering with Python. You fix it with config.</p>
<p>At minimum, you want buffering off for the SSE location and timeouts that won’t murder long streams.</p>
<p>Something like this (not gospel, but you get the idea):</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nginx" data-lang="nginx"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">location</span> <span class="s">/runs/</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">  <span class="kn">proxy_http_version</span> <span class="mi">1</span><span class="s">.1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">  <span class="kn">proxy_set_header</span> <span class="s">Connection</span> <span class="s">&#34;&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">  <span class="kn">proxy_buffering</span> <span class="no">off</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">  <span class="kn">proxy_cache</span> <span class="no">off</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">  <span class="kn">proxy_read_timeout</span> <span class="s">3600s</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">  <span class="kn">add_header</span> <span class="s">X-Accel-Buffering</span> <span class="s">no</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="p">}</span></span></span></code></pre></div><h2 id="the-other-gotchas-the-stuff-that-actually-bites-later">The other gotchas (the stuff that actually bites later)</h2>
<h3 id="dont-use-request-scoped-dependencies-in-your-background-worker">Don’t use request-scoped dependencies in your background worker</h3>
<p>If you have <code>Depends(get_db)</code> where <code>get_db</code> is a <code>yield</code> dependency, it gets cleaned up when the request is done.</p>
<p>If your worker is still running, it may now be holding a dead session/client.</p>
<p>Solution: the worker should acquire its own long-lived clients (Mongo, HTTP client, etc.) that are not tied to the request lifecycle.</p>
<h3 id="treat-status-updates-like-a-state-machine">Treat status updates like a state machine</h3>
<p>If you do <code>timeline_done</code> → <code>tasks_done</code> → <code>final_done</code>, don’t just write <code>tasks_done</code> unconditionally.</p>
<p>Do “only update if current status is timeline_done” (compare-and-set). Otherwise retries and races will eventually mess up your state.</p>
<h3 id="dont-confuse-survives-client-disconnect-with-durable">Don’t confuse “survives client disconnect” with “durable”</h3>
<p>This pattern survives a client disconnect. It does not survive:</p>
<ul>
<li>the process dying</li>
<li>the pod being evicted</li>
<li>a deploy that SIGTERMs the worker mid-step</li>
</ul>
<p>If the job truly must finish no matter what, use a real job system. SSE should subscribe to a job id, not be the job.</p>
<h3 id="decide-if-disconnect-should-cancel-the-job-explicitly">Decide if disconnect should cancel the job (explicitly)</h3>
<p>Some people will ask for “closing the tab cancels the job.”</p>
<p>That’s a separate feature. Don’t accidentally implement it via “oops, the client disconnected so the worker got canceled.”</p>
<p>If you want cancellation, do it explicitly:</p>
<ul>
<li>create a job id</li>
<li>store cancel intent</li>
<li>have the worker check it and stop cleanly</li>
</ul>
<p>Client disconnect is not a reliable cancel signal. It’s just the network being the network.</p>
<h2 id="a-boring-checklist-the-stuff-i-verify-before-i-trust-the-fix">A boring checklist (the stuff I verify before I trust the fix)</h2>
<ul>
<li>Start a step, then close the tab mid-stream → status still advances later</li>
<li>Start a step, refresh rapidly → no duplicate runs / no broken state transitions</li>
<li>Simulate a proxy timeout → completion still happens</li>
<li>Kill the SSE client (<code>curl -N ...</code> then <code>ctrl+c</code>) → completion still happens</li>
<li>Worker crashes mid-way → status reflects failure, and it doesn’t get stuck “in progress” forever</li>
</ul>
<h2 id="performance-notes-because-someone-will-ask">Performance notes (because someone will ask)</h2>
<p>The queue approach is usually cheap, but it’s not free.</p>
<ul>
<li>Memory: <code>queue_size * avg_event_size</code> per in-flight stream. Keep event payloads small.</li>
<li>CPU: queue ops are basically noise; the expensive bits are your DB/network calls.</li>
<li>DB load: if you add read-after-write verification (I sometimes do), it’s extra reads. Worth it if your system lies to you otherwise.</li>
</ul>
<p>The bigger risk isn’t CPU. It’s “we launched 500 background tasks because 500 people clicked the button.” Put a cap somewhere.</p>
<h2 id="deployment-strategy-how-i-roll-it-out-without-getting-yelled-at">Deployment strategy (how I roll it out without getting yelled at)</h2>
<ol>
<li>Staging: disconnect tests, refresh tests, and “kill the client” tests.</li>
<li>Canary: small percentage of traffic. Watch for stuck statuses.</li>
<li>Full rollout: watch completion rate for a day. If it drops, roll back fast.</li>
</ol>
<h2 id="how-i-tested-it-and-how-id-recommend-you-test-it">How I tested it (and how I’d recommend you test it)</h2>
<p>Nothing fancy. I just did the thing that used to break it:</p>
<ul>
<li>start the step</li>
<li>wait for a couple SSE updates</li>
<li>close the tab / refresh / kill the connection</li>
<li>watch MongoDB and server logs</li>
</ul>
<p>What I wanted to see is boring:</p>
<ul>
<li>status advances anyway</li>
<li>poller starts anyway</li>
<li>Slack fires anyway</li>
</ul>
<p>Once you watch the system finish without a client attached, you stop trusting “after the stream” code forever.</p>
<p>And honestly you should. It’s a trap.</p>

</content>
<p>
  
</p>


  <p>
    <a href='mailto:shentharkrishnatejaswi@gmail.com?subject=Reply%20to%20"SSE%20in%20FastAPI%3a%20The%20Tab%20Closed%20and%20My%20%e2%80%9cDone%e2%80%9d%20Code%20Never%20Ran"'>
      Reply to this post by email ↪
    </a>
  </p>



  </main>
  <footer><small>
  Krishnatejaswi S | Made with <a href="https://github.com/clente/hugo-bearcub">Bear Cub</a>
</small></footer>

    
</body>

</html>
